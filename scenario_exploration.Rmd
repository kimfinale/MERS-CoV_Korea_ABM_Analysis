---
output: html_document
editor_options: 
  chunk_output_type: console
chunk_output_type: console
---



### Parameter space exploration
```{r}
# using the run_java_abm function
source( "util/mers_ibm_funcs.R" )
param <- c(0.2, 1, 5 )
runs <-50 # number of runs for each parameter set

df <- data.frame()
d <-  matrix( NA, nrow=(runs+1), ncol=length(param))
d[ 1, ] <- param
d2 <- d
d3 <- d
for( i in 1:length(param) ){   
   res <- run_java_ibm( numruns=runs, beta=0.37, stepsize=0.2, 
                        delay_move = param[i] )
   d[ 2:(runs+1), i ] <- res$cumul_symptom_onset[ , ncol( res$cumul_symptom_onset )] ## total cumulative incidence
   d2[ 2:(runs+1), i ] <- res$num_hospital_infected
   d3[ 2:(runs+1), i ] <- res$var_mean_ratio
}
df <- as.data.frame( d )
names( df ) <- param
df_long <- reshape2::melt( df )

df2 <- as.data.frame( d2 )
names( df2 ) <- param
df2_long <- reshape2::melt( df2 )

df3 <- as.data.frame( d3 )
names( df3 ) <- param
df3_long <- reshape2::melt( df3 )

library(ggplot2)
ggplot( df_long ) +
   geom_boxplot( aes(variable, value, group=variable) )

ggplot( df2_long ) +
   geom_boxplot( aes(variable, value, group=variable) )

ggplot( df3_long ) +
   geom_boxplot( aes(variable, value, group=variable) )

```

### Baseline simulations
```{r}
source( "util/mers_ibm_funcs.R" )
library( dplyr )
fit <- readRDS( "out/pars_20181208T180504.rds" ) ## 30 out of 100 parameter sets  from ABC
fit_sample <- data.frame( beta = unique(fit$beta)[1:10], 
                          delay_move = unique(fit$delay_move)[1:10] )

fit_sample <- data.frame( beta=0.25, delay_move = 1.2 )
under_vacc <- FALSE
n_per_par <- 100
pars0 <- data.frame( expand.grid( under_Vacc = under_vacc,
                                  n_per_par = n_per_par ) )
fit_sample_long <- fit_sample %>% slice( rep( 1:n(), each = nrow(pars0) ) )

pars_long <- pars0
for( i in 1:(nrow( fit_sample )-1) ){
  pars_long <- rbind ( pars_long, pars0 )
}
pars <- cbind( fit_sample_long, pars_long )

library( parallel )
num_cores <- detectCores()
cl <- makeCluster( num_cores-1 )
clusterExport( cl, c( "run_java_ibm", "run_ibm_simple", "pars" ) )

res_cls <- parLapply( cl, 1:nrow(pars),
                      function(x) run_ibm_simple( 
                        iter = pars$n_per_par[ x ], 
                        beta = pars$beta[ x ],
                        delay_move = pars$delay_move[ x ], 
                        under_vaccination_scenario = pars$under_Vacc[ x ] ) ) 

stopCluster( cl )
# tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
# saveRDS( res_cls, paste0( "out/vacccov_relpop_", tstamp, ".rds") )
# saveRDS( pars, paste0( "out/pars_",tstamp, ".rds" ) )
```

#### Simulation based on ABC estimates
```{r message=FALSE, warning=FALSE, paged.print=FALSE}
source( "util/mers_ibm_funcs.R" )
runs <- length( abc$param[,1] ) # number of runs for each parameter set
m <-  matrix( NA, nrow=(runs+1), ncol=3 )
for( i in 1:runs ){   
   res <- run_java_ibm( numruns=1, stepsize = 0.2, 
                        beta = abc$param[ i, 1 ],
                        shape_gamma_offspring = abc$param[ i, 2 ],
                        factor_highrisk = abc$param[ i, 3 ],
                        delay_move = abc$param[ i, 4 ] )
   m[ i, 1 ] <- res$cumul_symptom_onset[ nrow( res$cumul_symptom_onset ), ]
   m[ i, 2 ] <- res$num_hospital_infected
   m[ i, 3 ] <- res$var_mean_ratio
}

library(tidyverse)
df <- tbl_df( m )
df <- gather( df, key, val )
ggplot( df ) +
   geom_boxplot( aes(key,val,group=key) )


```

### Simulation based on manual parameter set
```{r}
source( "util/mers_ibm_funcs.R" )
library(tidyverse)
fit <- readRDS( "out/beta_1_3Dec2018.rds" )
tstop = 60
npar = 100; #length( fit$param )
n_per_par = 1
nsample = npar * n_per_par

daily_symptom_onset <- matrix( NA, nrow=nsample, ncol=tstop ) # store sim res of the ibm
cumul_symptom_onset <- daily_symptom_onset # store sim res of the ibm
var_mean_ratio = rep( NA, nsample ) # store sim res of the ibm
num_hospital_infected = rep( NA, nsample ) # store sim res of the ibm
offspring_list <- list()
longitude_affected_hospital_list <- list()
latitude_affected_hospital_list <- list()

for( i in 1:npar ){
   # cat("i = ", i, "\n" )
   for( j in 1:n_per_par ){
      cat( "i = ", i, "j = ", j,"\n" )
      res <- run_java_ibm( stepsize = 0.2,
                           stoptime = tstop,
                           # beta = fit$param[ i ],
                           beta = 0.15,
                           delay_move = 1.2,
                           random_seed = (i-1)*n_per_par + j )
   
      cumul_symptom_onset[ (i-1)*n_per_par + j,  ] <- res$cumul_symptom_onset
      daily_symptom_onset[ (i-1)*n_per_par + j,  ] <- res$daily_symptom_onset
      var_mean_ratio[ (i-1)*n_per_par + j ] <-  res$var_mean_ratio
      num_hospital_infected[ (i-1)*n_per_par + j ] <- res$num_hospital_infected
      offspring_list[[ (i-1)*n_per_par + j ]] <- res$offspring_list
      longitude_affected_hospital_list[[ (i-1)*n_per_par + j ]] <- res$longitude_affected_hospital_list
      latitude_affected_hospital_list[[ (i-1)*n_per_par + j ]] <- res$latitude_affected_hospital_list
   }
}
## Date mark on the X-axis
dd = read.csv( "data/date.csv", header = FALSE )
ddd = as.Date( dd$V1, "%m/%d/%Y" )
# dat_symptom_onset_daily
source( path_symptom_onset_data ) # from mers_ibm_func.R file

ibm_avg <- colMeans( daily_symptom_onset )
ibm_q <- apply( daily_symptom_onset, 2, quantile, prob=c(0.025, 0.25, 0.5, 0.75, 0.975) )
ibm_m <- apply( daily_symptom_onset, 2, mean )
ibm_daily <- data_frame( day = ddd, 
                         q0025 = ibm_q[ 1, ],
                         q0250 = ibm_q[ 2, ],
                         q0500 = ibm_q[ 3, ],
                         q0750 = ibm_q[ 4, ], 
                         q0975 = ibm_q[ 5, ], 
                         avg = ibm_m )

sim <- gather( ibm_daily, stat, val, - day )

ibm2_avg <- colMeans( cumul_symptom_onset )
ibm2_q <- apply( cumul_symptom_onset, 2, quantile, prob=c(0.025, 0.25, 0.5, 0.75, 0.975) )
ibm2_m <- apply( cumul_symptom_onset, 2, mean )
ibm_cumul <- data_frame( day = ddd, 
                         q0025 = ibm2_q[ 1, ], 
                         q0250 = ibm2_q[ 2, ], 
                         q0500 = ibm2_q[ 3, ], 
                         q0750 = ibm2_q[ 4, ],
                         q0975 = ibm2_q[ 5, ], 
                         avg = ibm2_m )
sim2 <- gather( ibm_cumul, stat, val, - day )

d = tibble( day = ddd, daily = dat_symptom_onset_daily, cumul = dat_symptom_onset_cumul )

sim_wide = tidyr::spread( sim, stat, val )
sim_wide2 = tidyr::spread( sim2, stat, val )

ggplot() + 
   geom_col( data=d, aes( x=day, y=daily ) ) +
   # geom_point( data=sim_wide, aes( x=day, y=avg ), color="black", inherit.aes = FALSE ) +
   geom_line( data=sim_wide, aes( x=day, y=q0500 ), inherit.aes = FALSE, size=1.3 ) +
   geom_ribbon( data=sim_wide, aes( x=day, ymin=q0025, ymax=q0975 ), fill="red", alpha=0.2, inherit.aes = FALSE ) +
   geom_ribbon( data=sim_wide, aes( x=day, ymin=q0250, ymax=q0750 ), fill="red", alpha=0.4, inherit.aes = FALSE ) +
   labs( x="", y="Daily symptomatic cases") + 
   scale_x_date( date_labels="%B %d", limits=c(as.Date("2015-05-10"), as.Date("2015-07-10")) ) + 
   theme_classic() +
   # theme( panel.grid.major = element_line( colour="grey94" ) )
   theme( panel.grid.major = element_line( colour="#f0f0f0" ) )
 
# ggsave( "figs/daily_inc_fit.png", width=3.4*1.2, height=2.7*1.2, units="in" )

ggplot() +
   geom_col( data=d, aes( x=day, y=cumul ) ) +
   # geom_point( data=sim_wide2, aes( x=day, y=avg  ), color="black", inherit.aes = FALSE ) +
   geom_line( data=sim_wide2, aes( x=day, y=q0500 ), inherit.aes = FALSE, size=1.3 ) +
   geom_ribbon( data=sim_wide2, aes( x=day, ymin=q0025, ymax=q0975 ), fill="red", alpha=0.2, inherit.aes = FALSE ) +
   geom_ribbon( data=sim_wide2, aes( x=day, ymin=q0250, ymax=q0750 ), fill="red", alpha=0.5, inherit.aes = FALSE ) +
   labs( x="", y="Cumulative symptomatic cases") + 
   scale_x_date( date_labels="%B %d", limits=c(as.Date("2015-05-10"), as.Date("2015-07-10")) )+
   theme_classic() + 
   theme( panel.grid.major = element_line( colour="#f0f0f0" ) )
# ggsave( "figs/cumul_inc_fit.png", width=3.4*1.2, height=2.7*1.2, units="in" )

quantile( cumul_symptom_onset[,tstop], probs=c(0.025,0.5,0.975) )
mean( cumul_symptom_onset[,tstop] )
quantile( num_hospital_infected, probs=c(0.025,0.5,0.975) )
mean( num_hospital_infected )
quantile( var_mean_ratio, probs=c(0.025,0.5,0.975) )
mean( var_mean_ratio )
```



### Impact of vaccination programs 
```{r}
source( "util/mers_ibm_funcs.R" )
library(tidyverse)
tstop = 60
fit <- readRDS("out/beta_abc_beaumont_3.rds")
nsample = 100 ## length( fit$param )
# vacc_radius <- c(30,40,50,60,70,80,90)
vacc_threhold_case <- 5
vacc_threhold_day <- 14
vacc_radius <- 30
vacc_cov <- c( 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9 )
rel_pep <- c( 0.1, 0.3, 0.5 )
vacc_eff <- c( 0.3, 0.5, 0.7, 0.9 )
delay_vacc <- c( 7, 14, 21, 28 )
pars <- data.frame( expand.grid( vacc_cov = vacc_cov, rel_pep = rel_pep, vacc_eff = vacc_eff, delay_vacc = delay_vacc ) )
cumul_case <- matrix( NA, nrow = nsample, ncol = nrow(pars) ) # store sim res of the ibm
cumul_vacc <- cumul_case # store sim res of the ibm
vacc_status <- cumul_case # store sim res of the ibm
# for( i in 1:nrow(pars) ){
   for( i in 1:1 ){
   for( j in 1:nsample ) {
      cat("i = ", i, ", j = ", j, "\n" )
      res <- run_java_ibm( numruns=1, 
                           stepsize = 0.2,
                           stoptime = tstop,
                           beta = 0.14405,
                           delay_move = 1.2,
                           shape_gamma_offspring = 0.2,
                           vaccination_scenario = TRUE,
                           vacc_coverage = pars$vacc_cov[ i ],
                           vacc_efficacy = pars$vacc_eff[ i ],
                           rel_vacc_eff_post_exposure = pars$rel_pep[ i ],
                           delay_vacc = pars$delay_vacc[ i ],
                           vaccination_target_radius = vacc_radius,
                           threshold_case_vacc = as.integer( vacc_threhold_case ), 
                           threshold_day_vacc = as.integer( vacc_threhold_day ),
                           random_seed = j )
   
      cumul_case[ j, i ] <- res$cumul_symptom_onset[ tstop ]
      cumul_vacc[ j, i ] <- res$cumul_vacc_dose 
      vacc_status[ j, i ] <- res$vacc_day_adjusted
   }
}
list <- list()
list$cumul_case <- cumul_case
list$cumul_vacc <- cumul_vacc
list$vacc_status <- vacc_status
# filename <- ( "vacc_radius", sapply( 1:8, function(x) paste0("chi_",x) ) )
# saveRDS( list, "out/vacc_sim.RDS" )
```

#### Plot vaccine impact
```{r}
res <- readRDS( "out/vacc_sim.RDS" )
# ci <- apply( res$cumul_case, 2, quantile )
# ci_red <- 100 * ( 1 - ci[3,] / ci[3,1] )
# vacc <- apply( res$cumul_vacc, 2, quantile )
# case_averted  <- ci[3,1] - ci[3,]
# case_averted_per_10000 <- 10000 * case_averted / vacc[3,]
# res_df <- cbind( pars[1:36,], ci=ci[3,], ci_red=ci_red, vacc=vacc[3,], 
#                  case_averted = case_averted_per_10000 )

### calculating statistics by individual simulation
library(tidyverse)
ci_red <- 100*( 1 - res$cumul_case / res$cumul_case[,1] )
case_averted_per_10000 <- 10000 * (res$cumul_case[,1] - res$cumul_case ) / res$cumul_vacc

pars <- pars %>% slice( rep(1:n(), each = nsample ) )
resdf <- cbind(pars, ci_red=as.vector(ci_red), case_averted_per_10000=as.vector(case_averted_per_10000))

ggplot( filter(resdf, vacc_eff==0.3) ) +
   geom_boxplot( aes(as.factor(100*vacc_cov), ci_red, fill=as.factor(rel_pep) ),
                 position = position_dodge(width = .6) ) + 
   coord_cartesian(ylim=c(-100,100))+
   labs( x="Vacccination coverage(%)", y="Reduction of outbreak size (%)") +
   theme_classic() +
   theme( panel.grid.major = element_line( colour="#f0f0f0" ) )

# ggsave( "figs/vacc_cov_red.png", width=3.4*1.5, height=2.5*1.5, units="in" )

ggplot( filter(resdf, vacc_eff==0.3) ) +
   geom_boxplot( aes(as.factor(100*vacc_cov), case_averted_per_10000, fill=as.factor(rel_pep) ),
                 position = position_dodge(width = .6) ) + 
   coord_cartesian(ylim=c(-50,50))+
   labs( x="Vacccination coverage(%)", y="Case averted per 10,000 doses") +
   theme_classic() +
   theme( panel.grid.major = element_line( colour="#f0f0f0" ) )

# ggsave( "figs/vacc_cov_case.png", width=3.4*1.5, height=2.5*1.5, units="in" )

```
####
```{r}
### calculating statistics by individual simulation
library(tidyverse)
ci_red <- 100*( 1 - res$cumul_case / res$cumul_case[,1] )
case_averted_per_10000 <- 10000 * (res$cumul_case[,1] - res$cumul_case ) / res$cumul_vacc

pars <- pars %>% slice( rep(1:n(), each = nsample ) )
resdf <- cbind(pars, ci_red=as.vector(ci_red), case_averted_per_10000=as.vector(case_averted_per_10000))

ggplot( filter(resdf, vacc_eff==0.3) ) +
   geom_boxplot( aes(as.factor(100*vacc_cov), ci_red, fill=as.factor(rel_pep) ),
                 position = position_dodge(width = .6) ) + 
   coord_cartesian(ylim=c(-100,100))+
   labs( x="Vacccination coverage(%)", y="Reduction of outbreak size (%)") +
   theme_classic() +
   theme( panel.grid.major = element_line( colour="#f0f0f0" ) )

# ggsave( "figs/vacc_cov_red.png", width=3.4*1.5, height=2.5*1.5, units="in" )

ggplot( filter(resdf, vacc_eff==0.3) ) +
   geom_boxplot( aes(as.factor(100*vacc_cov), case_averted_per_10000, fill=as.factor(rel_pep) ),
                 position = position_dodge(width = .6) ) + 
   coord_cartesian(ylim=c(-50,50))+
   labs( x="Vacccination coverage(%)", y="Case averted per 10,000 doses") +
   theme_classic() +
   theme( panel.grid.major = element_line( colour="#f0f0f0" ) )

# ggsave( "figs/vacc_cov_case.png", width=3.4*1.5, height=2.5*1.5, units="in" )
```

### Parallel Simulation 
#### Threshold case 
```{r}
#### Vaccine coverage rates
rm(list=ls())
library(rJava)
options( java.parameters = "-Xmx4g" )
options( "java.parameters" )
library( EasyABC )
source( "util/mers_ibm_funcs.R" )
library( dplyr )
fit <- readRDS( "out/beta_delaymove_20181216T235939.rds" )
fit_sample <- data.frame( beta = fit$param[,1][16],
                          delay_move = fit$param[,2][16] )

threshold_case_vacc <- c( 1, 3, 5, 7, 9 )
threshold_day_vacc <- 21
vacc_radius <- 30
vacc_cov <- c( 0.0, 0.1, 0.3, 0.5, 0.7, 0.9 )
# vacc_cov <- c( 0.0, 0.9 )
rel_pep <- c( 0.5 )
vacc_eff <- c( 0.7 )
delay_vacc <- c( 7 )
dur_vacc <- c( 2 )
under_vacc <- TRUE
vacc_scenario <- c( "Distance", "Region", "Hospital" )
n_per_par <- 200

pars0 <- data.frame( expand.grid( vacc_cov = vacc_cov,
                                 rel_pep = rel_pep,
                                 vacc_eff = vacc_eff,
                                 delay_vacc = delay_vacc,
                                 under_vacc = under_vacc,
                                 vacc_scenario = vacc_scenario,
                                 vacc_radius = vacc_radius,
                                 threshold_case_vacc = threshold_case_vacc,
                                 threshold_day_vacc = threshold_day_vacc,
                                 dur_vacc = dur_vacc,
                                 n_per_par = n_per_par ), stringsAsFactors = FALSE )

fit_sample_long <- fit_sample %>% slice( rep( 1:n(), each = nrow(pars0) ) )
pars_long <- pars0

if( nrow(fit_sample) == 2 )
  pars_long <- rbind( pars0, pars0 )
if( nrow(fit_sample) > 2 ){
  for( i in 1:(nrow(fit_sample)-1) ){
    pars_long <- rbind ( pars_long, pars0 )
  }
}

pars <- cbind( fit_sample_long, pars_long )

tbegin <- Sys.time()


library(parallel)
num_cores <- detectCores()
cl <- makeCluster( num_cores-1 )
clusterExport( cl, c( "run_java_ibm", "run_ibm_simple", "pars" ) )
# res_cls <- parLapply( cl, 1:nrow(pars),
#                       function(x) run_ibm_simple(
#                          iter=pars$n_per_par[ x ],
#                          beta = pars$beta[ x ],
#                          delay_move = pars$delay_move[ x ],
#                          under_vaccination_scenario =  pars$under_vacc[ x ],
#                          vaccination_scenario = as.character( pars$vacc_scenario[ x ] ),
#                          vacc_coverage = pars$vacc_cov[ x ],
#                          vacc_efficacy = pars$vacc_eff[ x ],
#                          rel_vacc_eff_post_exposure = pars$rel_pep[ x ],
#                          delay_vacc = pars$delay_vacc[ x ],
#                          vaccination_target_radius = pars$vacc_radius[ x ],
#                          threshold_case_vacc = pars$threshold_case_vacc[ x ] ,
#                          threshold_day_vacc = pars$threshold_day_vacc[ x ],
#                          dur_vaccination = pars$dur_vacc[ x ]
#                          ) )
library(pbapply)
res_cls <- pblapply( 1:nrow(pars),
                      FUN = function(x) run_ibm_simple(
                         iter=pars$n_per_par[ x ],
                         beta = pars$beta[ x ],
                         delay_move = pars$delay_move[ x ],
                         under_vaccination_scenario =  pars$under_vacc[ x ],
                         vaccination_scenario = as.character( pars$vacc_scenario[ x ] ),
                         vacc_coverage = pars$vacc_cov[ x ],
                         vacc_efficacy = pars$vacc_eff[ x ],
                         rel_vacc_eff_post_exposure = pars$rel_pep[ x ],
                         delay_vacc = pars$delay_vacc[ x ],
                         vaccination_target_radius = pars$vacc_radius[ x ],
                         threshold_case_vacc = pars$threshold_case_vacc[ x ] ,
                         threshold_day_vacc = pars$threshold_day_vacc[ x ],
                         dur_vaccination = pars$dur_vacc[ x ]
                         ), cl=cl )


stopCluster( cl )
tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res_cls, paste0( "out/thresholdcase_par16_", tstamp, ".rds") )
saveRDS( pars, paste0( "out/pars_par16_",tstamp, ".rds" ) )
Sys.time()-tbegin

```

#### Vaccine coverage rates
```{r}
rm(list=ls())
library(rJava)
options( java.parameters = "-Xmx2g" )
options( "java.parameters" )
source( "util/mers_ibm_funcs.R" )
library( dplyr )
fit <- readRDS( "out/beta_delaymove_20181216T235939.rds" )
fit_sample <- data.frame( beta = fit$param[,1][10],
                          delay_move = fit$param[,2][10] )
# fit_sample <- data.frame( beta = 0.19, 
#                           delay_move = 1.69 )
threshold_case_vacc <- 1
threshold_day_vacc <- 14
vacc_radius <- 30
vacc_cov <- c( 0, 0.1, 0.3, 0.5, 0.7, 0.9 )
rel_pep <- c( 0.5 )
vacc_eff <- c( 0.3, 0.5, 0.7 )
delay_vacc <- c( 7 )
dur_vacc <- c( 2 )
under_vacc <- TRUE
vacc_scenario <- c( "Distance" )
n_per_par <- 100

pars0 <- data.frame( expand.grid( vacc_cov = vacc_cov,
                                 rel_pep = rel_pep,
                                 vacc_eff = vacc_eff,
                                 delay_vacc = delay_vacc,
                                 under_vacc = under_vacc,
                                 vacc_scenario = vacc_scenario,
                                 vacc_radius = vacc_radius,
                                 threshold_case_vacc = threshold_case_vacc,
                                 threshold_day_vacc = threshold_day_vacc,
                                 dur_vacc = dur_vacc,
                                 n_per_par = n_per_par ), stringsAsFactors = FALSE )

fit_sample_long <- fit_sample %>% slice( rep( 1:n(), each = nrow(pars0) ) )
pars_long <- pars0

if( nrow(fit_sample) == 2 )
  pars_long <- rbind( pars0, pars0 )
if( nrow(fit_sample) > 2 ){
  for( i in 1:(nrow(fit_sample)-1) ){
    pars_long <- rbind ( pars_long, pars0 )
  }
}

pars <- cbind( fit_sample_long, pars_long )

tbegin <- Sys.time()


library(parallel)
num_cores <- detectCores()
cl <- makeCluster( num_cores-1 )
clusterExport( cl, c( "run_java_ibm", "run_ibm_simple", "pars" ) )
# res_cls <- parLapply( cl, 1:nrow(pars),
#                       function(x) run_ibm_simple( 
#                          iter=pars$n_per_par[ x ], 
#                          # beta = 0.1924,
#                          # delay_move = 1.2,
#                          beta = pars$beta[ x ],
#                          delay_move = pars$delay_move[ x ], 
#                          under_vaccination_scenario =  pars$under_vacc[ x ],
#                          vaccination_scenario = as.character( pars$vacc_scenario[ x ] ),
#                          vacc_coverage = pars$vacc_cov[ x ],
#                          vacc_efficacy = pars$vacc_eff[ x ],
#                          rel_vacc_eff_post_exposure = pars$rel_pep[ x ],
#                          delay_vacc = pars$delay_vacc[ x ],
#                          vaccination_target_radius = pars$vacc_radius[ x ],
#                          threshold_case_vacc = pars$threshold_case_vacc[ x ] ,
#                          threshold_day_vacc = pars$threshold_day_vacc[ x ],
#                          dur_vaccination = pars$dur_vacc[ x ]
#                          ) ) 


stopCluster( cl )
tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res_cls, paste0( "out/vacccov_relpop_", tstamp, ".rds") )
saveRDS( pars, paste0( "out/pars_",tstamp, ".rds" ) )
Sys.time()-tbegin

```

#### Under importation, vaccine coverage rates
```{r}
source( "util/mers_ibm_funcs.R" )
library( dplyr )
fit <- readRDS( "out/beta_delaymove_20181216T235939.rds" )
fit_sample <- data.frame( beta = fit$param[,1][1:30],
                          delay_move = fit$param[,2][1:30] )
# fit_sample <- data.frame( beta = 0.19, 
#                           delay_move = 1.69 )
threshold_case_vacc <- 5
threshold_day_vacc <- 10
vacc_radius <- 30
vacc_cov <- c( 0.0, 0.1, 0.3, 0.5, 0.7, 0.9 )
rel_pep <- c( 0.5 )
vacc_eff <- c( 0.3, 0.5, 0.7 )
delay_vacc <- c( 7 )
dur_vacc <- c( 2 )
under_vacc <- TRUE
vacc_scenario <- c( "Distance" )
outbreak_scenario <- c( "Importation" )
n_per_par <- 100

pars0 <- data.frame( expand.grid( outbreak_scenario = outbreak_scenario,
                                  vacc_cov = vacc_cov,
                                 rel_pep = rel_pep,
                                 vacc_eff = vacc_eff,
                                 delay_vacc = delay_vacc,
                                 under_vacc = under_vacc,
                                 vacc_scenario = vacc_scenario,
                                 vacc_radius = vacc_radius,
                                 threshold_case_vacc = threshold_case_vacc,
                                 threshold_day_vacc = threshold_day_vacc,
                                 dur_vacc = dur_vacc,
                                 n_per_par = n_per_par ), stringsAsFactors = FALSE )

fit_sample_long <- fit_sample %>% slice( rep( 1:n(), each = nrow(pars0) ) )
pars_long <- pars0

if( nrow(fit_sample) == 2 )
  pars_long <- rbind( pars0, pars0 )
if( nrow(fit_sample) > 2 ){
  for( i in 1:(nrow(fit_sample)-1) ){
    pars_long <- rbind ( pars_long, pars0 )
  }
}

pars <- cbind( fit_sample_long, pars_long )

tbegin <- Sys.time()


library(parallel)
num_cores <- detectCores()
cl <- makeCluster( num_cores )
clusterExport( cl, c( "run_java_ibm", "run_ibm_simple", "pars" ) )
res_cls <- parLapply( cl, 1:nrow(pars),
                      function(x) run_ibm_simple( 
                         iter=pars$n_per_par[ x ], 
                         # beta = 0.1924,
                         # delay_move = 1.2,
                         outbreak_scenario = pars$outbreak_scenario[ x ], 
                         beta = pars$beta[ x ],
                         delay_move = pars$delay_move[ x ], 
                         under_vaccination_scenario =  pars$under_vacc[ x ],
                         vaccination_scenario = as.character( pars$vacc_scenario[ x ] ),
                         vacc_coverage = pars$vacc_cov[ x ],
                         vacc_efficacy = pars$vacc_eff[ x ],
                         rel_vacc_eff_post_exposure = pars$rel_pep[ x ],
                         delay_vacc = pars$delay_vacc[ x ],
                         vaccination_target_radius = pars$vacc_radius[ x ],
                         threshold_case_vacc = pars$threshold_case_vacc[ x ] ,
                         threshold_day_vacc = pars$threshold_day_vacc[ x ],
                         dur_vaccination = pars$dur_vacc[ x ]
                         ) ) 

stopCluster( cl )
tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res_cls, paste0( "out/vacccov_relpop_", tstamp, ".rds") )
saveRDS( pars, paste0( "out/pars_",tstamp, ".rds" ) )
Sys.time()-tbegin

```

##### Importation-driven dynamics 
```{r}
source( "util/mers_ibm_funcs.R" )
library( dplyr )
fit <- readRDS( "out/beta_delaymove_20181216T235939.rds" )
fit_sample <- data.frame( beta = fit$param[,1][1:30],
                          delay_move = fit$param[,2][1:30] )
threshold_case_vacc <- 5
threshold_day_vacc <- 10
vacc_radius <- 30
vacc_cov <- c( 0.0 )
rel_pep <- c( 0.5 )
vacc_eff <- c( 0.3 )
delay_vacc <- c( 7 )
dur_vacc <- c( 2 )
under_vacc <- FALSE
vacc_scenario <- c( "Distance" )
outbreak_scenario <- c( "Importation" )
n_per_par <- 1000

pars0 <- data.frame( expand.grid( outbreak_scenario = outbreak_scenario,
                                  vacc_cov = vacc_cov,
                                 rel_pep = rel_pep,
                                 vacc_eff = vacc_eff,
                                 delay_vacc = delay_vacc,
                                 under_vacc = under_vacc,
                                 vacc_scenario = vacc_scenario,
                                 vacc_radius = vacc_radius,
                                 threshold_case_vacc = threshold_case_vacc,
                                 threshold_day_vacc = threshold_day_vacc,
                                 dur_vacc = dur_vacc,
                                 n_per_par = n_per_par ), stringsAsFactors = FALSE )

fit_sample_long <- fit_sample %>% slice( rep( 1:n(), each = nrow(pars0) ) )
pars_long <- pars0

if( nrow(fit_sample) == 2 )
  pars_long <- rbind( pars0, pars0 )
if( nrow(fit_sample) > 2 ){
  for( i in 1:(nrow(fit_sample)-1) ){
    pars_long <- rbind ( pars_long, pars0 )
  }
}

pars <- cbind( fit_sample_long, pars_long )

tbegin <- Sys.time()

library(parallel)
num_cores <- detectCores()
cl <- makeCluster( num_cores-1 )
clusterExport( cl, c( "run_java_ibm", "run_ibm_default", "pars" ) )
res_cls <- parLapply( cl, 1:nrow(pars),
                      function(x) run_ibm_default( 
                         iter=pars$n_per_par[ x ], 
                         beta = pars$beta[ x ],
                         delay_move = pars$delay_move[ x ], 
                         under_vaccination_scenario =  pars$under_vacc[ x ],
                         vaccination_scenario = as.character( pars$vacc_scenario[ x ] ),
                         vacc_coverage = pars$vacc_cov[ x ],
                         vacc_efficacy = pars$vacc_eff[ x ],
                         rel_vacc_eff_post_exposure = pars$rel_pep[ x ],
                         delay_vacc = pars$delay_vacc[ x ],
                         vaccination_target_radius = pars$vacc_radius[ x ],
                         threshold_case_vacc = pars$threshold_case_vacc[ x ] ,
                         threshold_day_vacc = pars$threshold_day_vacc[ x ],
                         dur_vaccination = pars$dur_vacc[ x ]
                         ) ) 

stopCluster( cl )
tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res_cls, paste0( "out/importation_", tstamp, ".rds") )
saveRDS( pars, paste0( "out/pars_",tstamp, ".rds" ) )
Sys.time()-tbegin
```



#### Case isolation and contact tracing slowed
```{r}
rm(list=ls())
library(rJava)
options( java.parameters = "-Xmx2g" )
options( "java.parameters" )
source( "util/mers_ibm_funcs.R" )
library( dplyr )
fit <- readRDS( "out/beta_delaymove_20181216T235939.rds" )
fit_sample <- data.frame( beta = fit$param[,1][7:30],
                          delay_move = fit$param[,2][7:30] )


threshold_case_vacc <- 1
threshold_day_vacc <- 21
vacc_radius <- 30
vacc_cov <- c( 0.0, 0.1, 0.3, 0.5, 0.7, 0.9 )
meantime_isolation_middle = c( 2.400, 4.259 ) #c(4.259, 2.400, 0.500),
rel_pep <- c( 0.5 )
vacc_eff <- c( 0.7 )
delay_vacc <- c( 7 )
dur_vacc <- c( 2 )
under_vacc <- TRUE
vacc_scenario <- c( "Distance" )
outbreak_scenario <- c( "2015" )
n_per_par <- 200

pars0 <- data.frame( expand.grid( outbreak_scenario = outbreak_scenario,
                                  vacc_cov = vacc_cov, 
                                  meantime_isolation_middle = meantime_isolation_middle,
                                  rel_pep = rel_pep,
                                  vacc_eff = vacc_eff,
                                  delay_vacc = delay_vacc,
                                  under_vacc = under_vacc,
                                  vacc_scenario = vacc_scenario,
                                  vacc_radius = vacc_radius,
                                  threshold_case_vacc = threshold_case_vacc,
                                  threshold_day_vacc = threshold_day_vacc,
                                  dur_vacc = dur_vacc,
                                  n_per_par = n_per_par ), stringsAsFactors = FALSE )

fit_sample_long <- fit_sample %>% slice( rep( 1:n(), each = nrow(pars0) ) )
pars_long <- pars0

if( nrow(fit_sample) == 2 )
  pars_long <- rbind( pars0, pars0 )
if( nrow(fit_sample) > 2 ){
  for( i in 1:(nrow(fit_sample)-1) ){
    pars_long <- rbind ( pars_long, pars0 )
  }
}

pars <- cbind( fit_sample_long, pars_long )

tbegin <- Sys.time()


library(parallel)
num_cores <- detectCores()
cl <- makeCluster( num_cores )
clusterExport( cl, c( "run_java_ibm", "run_ibm_simple", "pars" ) )
# res_cls <- parLapply( cl, 1:nrow(pars),
#                       function(x) run_ibm_simple( 
#                          iter = pars$n_per_par[ x ], 
#                          meantime_isolation = c( 4.259, pars$meantime_isolation_middle[ x ], 0.500 ),
#                          outbreak_scenario = pars$outbreak_scenario[ x ], 
#                          beta = pars$beta[ x ],
#                          delay_move = pars$delay_move[ x ], 
#                          under_vaccination_scenario = pars$under_vacc[ x ],
#                          vaccination_scenario = as.character( pars$vacc_scenario[ x ] ),
#                          vacc_coverage = pars$vacc_cov[ x ],
#                          vacc_efficacy = pars$vacc_eff[ x ],
#                          rel_vacc_eff_post_exposure = pars$rel_pep[ x ],
#                          delay_vacc = pars$delay_vacc[ x ],
#                          vaccination_target_radius = pars$vacc_radius[ x ],
#                          threshold_case_vacc = pars$threshold_case_vacc[ x ] ,
#                          threshold_day_vacc = pars$threshold_day_vacc[ x ],
#                          dur_vaccination = pars$dur_vacc[ x ]
#                          ) ) 


## To incldue progress bar
library(pbapply)
res_cls <- pblapply( 1:nrow(pars),
                      FUN = function(x) run_ibm_simple( 
                         iter = pars$n_per_par[ x ], 
                         meantime_isolation = c( 4.259, pars$meantime_isolation_middle[ x ], 0.500 ),
                         outbreak_scenario = pars$outbreak_scenario[ x ], 
                         beta = pars$beta[ x ],
                         delay_move = pars$delay_move[ x ], 
                         under_vaccination_scenario = pars$under_vacc[ x ],
                         vaccination_scenario = as.character( pars$vacc_scenario[ x ] ),
                         vacc_coverage = pars$vacc_cov[ x ],
                         vacc_efficacy = pars$vacc_eff[ x ],
                         rel_vacc_eff_post_exposure = pars$rel_pep[ x ],
                         delay_vacc = pars$delay_vacc[ x ],
                         vaccination_target_radius = pars$vacc_radius[ x ],
                         threshold_case_vacc = pars$threshold_case_vacc[ x ] ,
                         threshold_day_vacc = pars$threshold_day_vacc[ x ],
                         dur_vaccination = pars$dur_vacc[ x ]
                         ), cl=cl ) 


stopCluster( cl )
tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res_cls, paste0( "out/isolation_vacccov_", tstamp, ".rds") )
saveRDS( pars, paste0( "out/pars_",tstamp, ".rds" ) )
Sys.time()-tbegin
```


#### parLapply test
```{r}
parLapply_test <- function(x) {
  Sys.sleep(100)
  tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
  saveRDS( x, paste0( "out/parLapply_test_ind_", tstamp, ".rds") )
  return(x)
  
}
library(parallel)
num_cores <- detectCores()
cl <- makeCluster( num_cores-1 )
clusterExport( cl, c( "parLapply_test") )
res_cls <- parLapply( cl, 1:3, function(x) parLapply_test(x) )  

stopCluster( cl )
closeAllConnections()
tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res_cls, paste0( "out/parLapply_test", tstamp, ".rds") )


res <- readRDS("out/vacccov_relpop_20181210T205517.rds")
pars <- readRDS("out/pars_20181210T205517.rds")
```

#### Serial processing using lapply
```{r}
#### Simulation across vaccine coverage rates
source( "util/mers_ibm_funcs.R" )
library( dplyr )
fit <- readRDS( "out/pars_20181208T180504.rds" )
fit_sample <- data.frame( beta = unique(fit$beta)[1:10], 
                          delay_move = unique(fit$delay_move)[1:10] )

threshold_case_vacc <- 5
threshold_day_vacc <- 14
vacc_radius <- 30
vacc_cov <- c( 0.0, 0.1, 0.3, 0.5, 0.7, 0.9 )
rel_pep <- c( 0.5 )
# vacc_eff <- c( 0.3, 0.5, 0.7 )
vacc_eff <- c( 0.7 )
delay_vacc <- c( 14 )
under_vacc <- TRUE
vacc_scenario <- c( "Distance" )
n_per_par <- 40

pars0 <- data.frame( expand.grid( vacc_cov = vacc_cov,
                                 rel_pep = rel_pep,
                                 vacc_eff = vacc_eff,
                                 delay_vacc = delay_vacc,
                                 under_vacc = under_vacc,
                                 vacc_scenario = vacc_scenario,
                                 vacc_radius = vacc_radius,
                                 threshold_case_vacc = threshold_case_vacc,
                                 threshold_day_vacc = threshold_day_vacc,
                                 n_per_par = n_per_par ), stringsAsFactors = FALSE )

fit_sample_long <- fit_sample %>% slice( rep( 1:n(), each = nrow(pars0) ) )

pars_long <- rbind( pars0, pars0 )
for( i in 1:(nrow( fit_sample )-2) ){
  pars_long <- rbind ( pars_long, pars0 )
}

pars <- cbind( fit_sample_long, pars_long )

res_cls <- lapply( 1:nrow(pars),
                      function(x) run_ibm_simple( 
                         iter=pars$n_per_par[ x ], 
                         # beta = 0.1924,
                         # delay_move = 1.2,
                         beta = pars$beta[ x ],
                         delay_move = pars$delay_move[ x ], 
                         under_vaccination_scenario =  pars$under_vacc[ x ],
                         vaccination_scenario = as.character( pars$vacc_scenario[ x ] ),
                         vacc_coverage = pars$vacc_cov[ x ],
                         vacc_efficacy = pars$vacc_eff[ x ],
                         rel_vacc_eff_post_exposure = pars$rel_pep[ x ],
                         delay_vacc = pars$delay_vacc[ x ],
                         vaccination_target_radius = pars$vacc_radius[ x ],
                         threshold_case_vacc = pars$threshold_case_vacc[ x ] ,
                         threshold_day_vacc = pars$threshold_day_vacc[ x ]
                         ) ) 


tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res_cls, paste0( "out/vacccov_relpop_", tstamp, ".rds") )
saveRDS( pars, paste0( "out/pars_",tstamp, ".rds" ) )

```


### Outbreak duration 
```{r}

#### Time to extinction
 
ls_vacc = lapply( 1:length(index), function(x) mat[ , index[[x]] ] )

find_day_extinct = function( mat=NULL ){
   days = rep( NA, ncol(mat) )
   # find days (id) where I = 0
   for( i in 1:ncol(mat) ){
      vec = mat[ , i ]
      v = 1:length(vec)
      d = v[ vec == 0 ]
   # find a position where id is not continuous
      loc = (d[ 2:length(d)] - d[ 1:(length(d)-1) ]) > 1
      days[ i ] = max( d[ c(TRUE, loc) ] ) # TRUE is inserted to move the index one later
   }
   return( days )
}

days = lapply( 1:6, function(x) find_day_extinct( ls_vacc[[ x ]] ) )

delay_vacc = 0; # simulation start and vaccination start
d = data_frame( x = days[[1]], vacc_cov = 0L )
d = rbind( d, data_frame( x = days[[2]]-delay_vacc, vacc_cov = 20L ))
d = rbind( d, data_frame( x = days[[3]]-delay_vacc, vacc_cov = 40L ))
d = rbind( d, data_frame( x = days[[4]]-delay_vacc, vacc_cov = 60L ))
d = rbind( d, data_frame( x = days[[5]]-delay_vacc, vacc_cov = 80L ))
d = rbind( d, data_frame( x = days[[6]]-delay_vacc, vacc_cov = 100L ))

ggplot( d ) + 
   geom_boxplot ( aes(vacc_cov, x, group=vacc_cov) ) +
   scale_x_continuous( limits=c(-10,110), breaks=seq(0,100,20) ) +
   scale_y_continuous( limits=c(0,60), breaks=seq(0,60,10) ) +
   labs( x = "Vaccine coverage rate (%)", y = "Epidemic duration" ) + 
   theme_classic() +
   theme( panel.grid.major = element_line( colour="#f0f0f0" ) )
   
ggsave( "figs/epi_dur.png", width=3.4*1.2, height=2.5*1.2, units="in" )

# d$vacc_cov = factor( d$vacc_cov, levels = c("No vaccination","20%","40%","60%","80%","100%") )
# d = dplyr::filter( d, vacc_cov %in% c("No vaccination", "100%") )

# ggplot( d, aes(x = x) ) +
#    geom_density( aes( group=vacc_cov, fill=vacc_cov), alpha=0.3 ) +
#    guides( fill=guide_legend(title="") ) +
#    theme_pub() +
#    scale_x_continuous( limits=c(0,50) ) +
#    labs( x = "Time (day) to extinction since vaccination started", y = "Density" ) +
#    theme( legend.position = c(0.2,0.88),
#           legend.direction = "vertical",
#           legend.key.size = unit( 6, "mm" ) )

# ggplot( d, aes(x = x) ) + 
#    geom_histogram( aes( group=vacc_cov, fill=vacc_cov), binwidth=1,  position="dodge" ) +
#    guides( fill=guide_legend(title="") ) +
#    theme_pub() +
#    scale_x_continuous( limits=c(0,50) ) +
#    scale_y_continuous( breaks=seq(0,16,2) ) +
#    labs( x = "Time (day) to extinction since vaccination started", y = "Frequency" ) + 
#    theme_classic() +
#    theme( panel.grid.major = element_line( colour="#f0f0f0" ) )
#    theme( legend.position = c(0.2,0.88), 
#           legend.direction = "vertical", 
#           legend.key.size = unit( 6, "mm" ) )


```


### Fitting offspring distribution 
```{r}
library( dplyr )
# offspring_list from the many runs
res_control <- readRDS( "out/control_20181209T231219.rds" )
offspring_list <- lapply( 1:length(res_control), function(x) res_control[[x]]$offspring_list )
offspring_list <- unlist( offspring_list, recursive = FALSE )
freq <- data.frame()
for( i in 1:length( offspring_list ) ){
   d <- tbl_df( unlist( offspring_list[[i]] ) )
   dd <- 
      d %>%
      group_by( value ) %>%
      summarise (n = n()) %>%
      mutate( freq = n / sum(n) )
   
   freq <- rbind( freq, dd )
}

dd_ <- freq %>% dplyr::select( value, freq )

med <- rep( NA, 100 )
lower <- upper <- n <- med

for( i in 0:99 ){
   d = filter( dd_, value == i )
   n[i+1] = i
   med[i+1] = quantile( d$freq, probs=0.5 )
   upper[i+1] = quantile( d$freq, probs=0.975 )
   lower[i+1] = quantile( d$freq, probs=0.025 )
}
offspring_sim = tbl_df( cbind( med, upper, lower ) )

dat_case = c( 0, 1, 2, 6, 11, 23, 28, 79 )
dat_freq = c( 170, 7, 4, 1, 1, 1, 1, 1 ) / 186

dat_offspring = data_frame( case = 0:80, freq=rep(NA,81) )
dat_offspring[ dat_case+1, 2 ] = dat_freq
library( ggplot2 )
ggplot( offspring_sim ) + 
  geom_col( data=dat_offspring, mapping = aes(case, freq), inherit.aes = FALSE ) + 
  labs( x="Offspring size", y="Relative frequency" ) + 
  geom_errorbar( aes( x=n, ymin=lower, ymax=upper), position = 'dodge', width=0.25, color="red" ) +
  geom_point ( aes( n, med ), stat = "identity", color="red", alpha=0.3 ) + 
  xlim( -0.5, 80 ) +
  theme_classic() + 
  theme( panel.grid.major = element_line( colour="#f0f0f0" ) ) + 
  geom_rect( xmin=68, xmax=70, ymin=0.8, ymax=0.82, fill="grey30") +
  geom_point( aes(69, 0.77), color="red", inherit.aes = FALSE ) + 
  annotate( "text", x = 76, y = 0.82, label="Data") + 
  annotate( "text", x = 76, y = 0.77, label="Model")  
   
# ggsave( "figs/offspring.png", width=3.4*1.2, height=2.5*1.2, units="in" )
```


### Mapping the hospitals where transmissions occurred
```{r}
library( rgdal )
library( broom )
library( plyr )
library( rgeos )
library( maptools )
library( ggplot2 )
library( dplyr )
library( viridis )
source( util/mer)
# Preparing the base Korean map
source( "util/mers_ibm_funcs.R" )

korea <- readOGR( dsn = path_Korea_shapefile, layer="KOR_adm1" )
korea@data$id <- rownames( korea@data )
korea_points <- broom::tidy( korea, region="id" )
korea_df <- join( korea_points, korea@data, by="id" )
# Extracting outbreak info from typhoid occurrence database
# read the outbreak data in excel file
library(readxl)
library(purrr)
library(readxl)
d <- read_xlsx( "C:/Users/jongHoon.kim/Workspace/IVI_Projects/MERS/MERS-CoV_Korea_ABM_Analysis/ABM_Analysis/out/hospital_pop.xlsx" )
d$X_POS <- as.double( d$X_POS )
d$Y_POS <- as.double( d$Y_POS )
# dd <- filter(d, grepl( "????????????", d$YADM_NM.x))
# MERS-CoV affected hospitals
mers_hosp <- read_xlsx( "C:/Users/jongHoon.kim/Workspace/IVI_Projects/MERS/Data_Analysis/data/mers-cov_hospitals.xlsx" )
# simulated hospitals
## save the data in case you want to the plot again
res_control <- readRDS( "out/control_20181209T231219.rds" )
lon <- sapply( 1:length(res_control), function(x) unlist(res_control[[x]]$longitude_affected_hospital_list) )
               
lat <- sapply( 1:length(res_control), function(x) unlist(res_control[[x]]$latitude_affected_hospital_list) )

sim_hosp <- data.frame( lon=unlist(lon), lat=unlist(lat) )

ggplot( data = korea_df ) + 
  geom_polygon( aes(x=long, y=lat, group=group ), fill=NA, color = "black" ) +
  expand_limits( x = korea_df$long, y=korea_df$lat ) + 
  # geom_point( data=d, aes(x=X_POS, y=Y_POS), shape=16, size=log10(d$POP_RISK), alpha=0.1, color="grey", inherit.aes=FALSE ) + 
  geom_point( data=sim_hosp, aes(x=lon, y=lat), shape=16, size=3, alpha=0.005, color="red", inherit.aes=FALSE ) +
  geom_point( data=mers_hosp, aes(x=X, y=Y), shape=16, size=3, color="royalblue", alpha=0.25, inherit.aes=FALSE ) + 
 
  theme( 
        panel.background = element_blank(), # bg of the panel
        plot.background = element_blank(), # bg of the plot
        legend.background = element_blank(), # get rid of legend bg
        legend.box.background = element_blank(),
        panel.spacing = unit( c(0,0,0,0), "null" ),
        plot.margin = unit( c(0,0,0,0), "null" ), 
        axis.line = element_blank(), 
        axis.text.x = element_blank(),
        axis.text.y = element_blank(), 
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = c( 0.2, 0.3 ) ) 

 ggsave( "figs/hosp_mers_map_data.png" )
```

### Many runs by setting parameter values manually
```{r message=FALSE, warning=FALSE, paged.print=FALSE}
# setwd( "C:/Users/jongHoon.kim/workspace/IVI_Projects/MERS/Transmission_Modeling/" )
source( "util/mers_ibm_funcs.R" )
source( "data/mers_symptom_onset_data.R" )
java_class_path_setup()
library(tidyverse)

res <- run_java_ibm( numruns=100, stepsize=0.2, scenario="2015" )
endrow <- nrow( res$cumul_symptom_onset )

quantile( res$cumul_symptom_onset[ endrow, ], probs=c(0.025,0.5,0.975) )
quantile( res$var_mean_ratio, probs=c(0.025,0.5,0.975), na.rm=TRUE )
quantile( res$num_hospital_infected, probs=c(0.025,0.5,0.975) )
mean( res$cumul_symptom_onset[ stoptime, ] )
mean( res$var_mean_ratio, na.rm=TRUE )
mean( res$num_hospital_infected )
res$offspring_list[[1]]

dd = read.csv( "data/date.csv", header = FALSE )
ddd = as.Date( dd$V1, "%m/%d/%Y" )

mat <- res$daily_symptom_onset
mat2 <- res$cumul_symptom_onset

ibm_avg <- rowMeans( mat )
ibm_q <- apply( mat, 1, quantile, prob=c(0.025, 0.25, 0.5, 0.75, 0.975) )
ibm_q_t = t(ibm_q)
ibm_m <- apply( mat, 1, mean )
ibm_daily <- data_frame( date = ddd, 
                         q0025 = ibm_q_t[ ,1],
                         q0250 = ibm_q_t[ ,2],
                         q0500 = ibm_q_t[ ,3],
                         q0750 = ibm_q_t[ ,4], 
                         q0975 = ibm_q_t[ ,5], 
                         avg = ibm_m )

sim <- gather( ibm_daily, stat, val, - date )

ibm2_avg <- rowMeans( mat2 )
ibm2_q <- apply( mat2, 1, quantile, prob=c(0.025, 0.25, 0.5, 0.75, 0.975) )
ibm2_m <- apply( mat2, 1, mean )

ibm_cumul <- data_frame( date = ddd, 
                         q0025 = t(ibm2_q)[,1], 
                         q0250 = t(ibm2_q)[,2], 
                         q0500 = t(ibm2_q)[,3], 
                         q0750 = t(ibm2_q)[,4],
                         q0975 = t(ibm2_q)[,5], 
                         avg = ibm2_m )
sim2 <- gather( ibm_cumul, stat, val, - date )

d = tibble( date = ddd, daily = dat_symptom_onset_daily, cumul = dat_symptom_onset_cumul )


sim_wide = tidyr::spread( sim, stat, val )
sim_wide2 = tidyr::spread( sim2, stat, val )

# source( "util/ggplot2_theme.r" )
ggplot() + 
   geom_col( data=d, aes( x=date, y=daily ) ) +
   geom_point( data=sim_wide, aes( x=date, y=avg ), color="black", inherit.aes = FALSE ) +
   geom_line( data=sim_wide, aes( x=date, y=q0500 ), inherit.aes = FALSE, size=1.5 ) +
   geom_ribbon( data=sim_wide, aes( x=date, ymin=q0025, ymax=q0975 ), fill="red", alpha=0.2, inherit.aes = FALSE ) +
   geom_ribbon( data=sim_wide, aes( x=date, ymin=q0250, ymax=q0750 ), fill="red", alpha=0.4, inherit.aes = FALSE ) +
   labs( x="", y="Daily symptomatic cases") + 
   scale_x_date( date_labels="%B %d", limits=c(as.Date("2015-05-10"), as.Date("2015-07-10")) )

   # theme_classic() +
   # theme( panel.grid.major = element_line( colour="grey94" ) )
   # theme( panel.grid.major = element_line( colour="#f0f0f0" ) )
   # theme_pub()

 # ggsave( "figs/daily_7Setp2018.png", width=3.4*1.2, height=2.5*1.2, units="in"  )

ggplot() +
   geom_col( data=d, aes( x=date, y=cumul ) ) +
   geom_point( data=sim_wide2, aes( x=date, y=avg ), color="black", inherit.aes = FALSE ) +
   geom_line( data=sim_wide2, aes( x=date, y=q0500 ), inherit.aes = FALSE, size=1.5 ) +
   geom_ribbon( data=sim_wide2, aes( x=date, ymin=q0025, ymax=q0975 ), fill="red", alpha=0.2, inherit.aes = FALSE ) +
   geom_ribbon( data=sim_wide2, aes( x=date, ymin=q0250, ymax=q0750 ), fill="red", alpha=0.5, inherit.aes = FALSE ) +
   labs( x="", y="Cumulative symptomatic cases") + 
   scale_x_date( date_labels="%B %d", limits=c(as.Date("2015-05-10"), as.Date("2015-07-10")) )

```


### Outbreak size distribution upon importation
```{r message=FALSE, warning=FALSE, paged.print=FALSE}
#### Simulation across vaccine coverage rates
source( "util/mers_ibm_funcs.R" )
library( dplyr )
fit <- readRDS( "out/pars_20181208T180504.rds" )
fit_sample <- data.frame( beta = unique(fit$beta), 
                          delay_move = unique(fit$delay_move) )
under_vacc <- FALSE
n_per_par <- 40
outbreak_scenario <- "Importation"
pars <- data.frame( beta = fit_sample$beta,
                    delay_move = fit_sample$delay_move, 
                    n_per_par = n_per_par,
                    under_vacc = under_vacc,
                    outbreak_scenario = outbreak_scenario )
library(parallel)
num_cores <- detectCores()
cl <- makeCluster( num_cores-1 )
clusterExport( cl, c( "run_java_ibm", "run_ibm_simple", "pars" ) )
res_cls <- parLapply( cl, 1:nrow(pars),
# res_cls <- lapply( 1:nrow(pars),
                      function(x) run_ibm_simple( 
                         iter = pars$n_per_par[ x ], 
                         beta = pars$beta[ x ],
                         delay_move = pars$delay_move[ x ], 
                         under_vaccination_scenario = pars$under_vacc[ x ],
                         outbreak_scenario = as.character( pars$outbreak_scenario[ x ] ) ) ) 
stopCluster( cl )
tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res_cls, paste0( "out/importation_", tstamp, ".rds") )
saveRDS( pars, paste0( "out/pars_",tstamp, ".rds" ) )


```

#### Plot importation-driven outbreak size distribution
```{r}
res <- readRDS( "out/importation_20181211T164655.rds" )
ci <- sapply( seq_along(res), function(x) unlist( res[[x]]$cumul_symptom_onset ) ) 
d <- data.frame( ci = as.vector( ci ) )
library( ggplot2 )
ggplot( d ) +
   geom_histogram( aes( x=ci ), binwidth = 50 ) +
   labs( x="Outbreak size", y="Frequency" ) +
   theme_classic() +
   theme( panel.grid.major = element_line( colour="grey94" ) )
#    
# ggsave( "figs/outbreak_size_distribution.png", width=3.4*1.5, height=2.5*1.5, units="in" )

ggplot( d, aes(ci) ) +
  stat_ecdf( geom = "point" ) +
  stat_ecdf( geom = "step" ) +
  geom_vline( xintercept = 187 ) +
  geom_hline( yintercept = ecdf( d$ci )( 187 ) ) +
  geom_point( aes(187, ecdf( d$ci )( 187 )), color="red", size=1.5, inherit.aes=FALSE ) +
  labs( x="Outbreak size", y="Cumulative probabability" ) +
  theme_classic() +
  theme( panel.grid.major = element_line( colour="grey94" ) ) + 
  annotate( "text", x=2500, y=0.88, label = "2015 Korean MERS-CoV outbreak (93.7 percentile)", size=3 )
# ggsave( "figs/outbreak_size_distribution_cumul.png", width=3.4*1.5, height=2.5*1.5, units="in" )  

ci_ordered <- d$ci[ order(d$ci) ]
cdf <- ecdf( d$ci )
cdf_val <- cdf( ci_ordered )
d <- bind_cols( data_frame( t=1:nrow(daily_symptom_onset) ), tbl_df(daily_symptom_onset) ) 
d_long <- gather( d, key, val, -t)
ggplot( d_long ) +
   geom_line( aes( x=t, y=val, color=key ), alpha=0.2, show.legend=FALSE ) + 
   scale_color_manual( values=rep("black",1000) ) +
   labs( x="Day", y="Symptom onset" ) +
   theme_classic() +
   theme( panel.grid.major = element_line( colour="grey94" ) )

# ggsave( "figs/outbreak_size_distribution.png", width=3.4*1.5, height=2.5*1.5, units="in" )
```
#### Statistics on importation-driven outbreaks
```{r}
res <- readRDS( "out/importation_20181221T143502.rds" )

ci <- sapply( seq_along(res), function(x) unlist( res[[x]]$cumul_symptom_onset ) ) 
d <- data.frame( ci = as.vector( ci ) )
table( d$ci )
  
```



#### Probability of outbreak of size k or larger given the number of cases observed in t1 days after the first case developed symptoms (and imported) on day t0
```{r}
# data
res <- readRDS( "out/importation_20181221T143502.rds" )
pars <- readRDS( "out/pars_20181221T143502.rds" )

ci <- sapply( seq_along(res), function(x) unlist( res[[x]]$cumul_symptom_onset ) ) 
d <- data.frame( ci = as.vector( ci ) )
# ci <- tbl_df( cumul_symptom_onset )
ci <- tbl_df( t(cumul_symptom_onset) )

library(tidyverse)
cut_off <- seq( 1, 50, 1 )
time <- 1:50
df <- tbl_df( expand.grid( time=time, cut_off=cut_off ) )
df$prob_outbreak <- NA
df$prob_occurrence <- NA


index = 1

for( i in 1:length(cut_off) ){
   for( j in 1:length(time) ) {
      con_1 <- function(x) x[ j ] >= df$cut_off[ i ]
      con_2 <- function(x) tail(x,1) > 100
      d1 <- ci %>% select_if( con_1 )
      d2 <- d1 %>% select_if( con_2 )

      if( ncol(d1) > 0 ){
         df[ index, "prob_outbreak" ] <- ncol( d2 ) / ncol( d1 )
      }
      df[ index, "prob_occurrence" ] <- ncol( d1 ) / ncol( ci )
      index <- index + 1
   }
}
mers_d <- data.frame( time=1:60, ci=dat_symptom_onset_cumul )

library(viridis)
ggplot( df, aes(time, cut_off ) ) +
   expand_limits( x = 0, y = 0 ) +
   geom_tile( aes( fill = prob_outbreak ), color = "white") +
   geom_point( data=mers_d, aes( x=time, y=ci ), color="red", inherit.aes = FALSE) +
   scale_x_continuous( limits=c(0,31) ) +
   scale_y_continuous( limits=c(0,51) ) +
   scale_fill_viridis() +
   labs( x="Day since symptom onset of the index case", y="MERS-CoV incidence", 
         fill="Prob.of an oubreak of size >100 " ) +
   theme_classic() + 
   theme( legend.position="bottom" )
# ggsave( "figs/outbreak_prob_mers_100.png", width=3.4*1.5, height=2.5*1.5, units="in" )
library(viridis)
ggplot( df, aes(time, cut_off ) ) +
   expand_limits( x = 0, y = 0 ) +
   geom_tile( aes( fill = prob_occurrence ), color = "white") +
   geom_point( data=mers_d, aes( x=time, y=ci ), color="red", inherit.aes = FALSE) +
   scale_x_continuous( limits=c(0,31) ) +
   scale_y_continuous( limits=c(0,31) ) +
   scale_fill_viridis() +
   labs( x="Day since symptom onset of the index case", y="MERS-CoV incidence", 
         fill="Prob " ) +
   theme_classic() + 
   theme( legend.position="bottom" )

# ggsave( "figs/incidence_prob.png", width=3.4*1.5, height=2.5*1.5, units="in" )
```

### Differential equations of vaccine-induced immunity
```{r}

library(deSolve)
vacc_ode <- function( t, y, parms ) {
  r <- parms[ 1 ]
  g <- parms[ 2 ]
  
  dy1 <- -r * y[ 1 ]
  dy2 <- + r * y[ 1 ] - g * y[ 2 ]
  dy3 <- + g * y[ 2 ] 

  list(c(dy1, dy2, dy3))
}

yini <- c( y1 = 1, y2 = 0, y3 = 0 )
times <- seq( from = 0, to = 60, by = 0.01)
parms <- c( 0.02, 1/14 )
out <- ode ( times = times, y = yini, func = vacc_ode, parms = parms )
# head (out, n = 3)
class(out) <- "matrix" # without this, dplyr functions get error
out <- tbl_df( out )
colnames( out ) <- c( "Day", "S", "VS", "VP" )
# write.csv( out, "sir_tr_05.csv", row.names = FALSE )
out <- gather( out, var, num, - Day )
out$var <- factor( out$var  )
out$model <- "Numerical"

## Analytical solutions
r <- parms[1]
g <- parms[2]
t <- times
S <- exp(-r*t)
VS <- (r*exp(t*(-g-r))*(exp(g*t)-exp(r*t)))/(g-r)
VP <- (exp(t*(-g-r))*(exp(r*t)*((g-r)*exp(g*t)+r)-g*exp(g*t)))/(g-r)

df <- data.frame( Day = t, S = S, VS = VS, VP = VP )
df <- gather( df, var, num, - Day )
df$model <- "Analytical"

d <- rbind( out, df )
d$model <- factor( d$model )
ggplot( d ) + 
    geom_line( aes( x=Day, y=num, color=var ) ) +
    labs( x="Time (day)", y="Fraction of population", color="Status" ) + 
    facet_wrap(.~model)
    theme( legend.position=c(0.85,0.45) )


```


